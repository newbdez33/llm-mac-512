# mlx-community/MiniMax-M2.1-4bit 性能测试报告

> 测试时间: 2026-02-02T12:19:06.324601
> 框架: MLX

## 系统信息

| 项目 | 值 |
|------|-----|
| platform | macOS |
| python_version | Python 3.12.12 |
| macos_version | 26.2 |
| chip | Apple M3 Ultra |
| total_memory_gb | 512.0 |
| mlx_version | 0.30.4 |

## 性能指标

| 指标 | 值 |
|------|-----|
| 模型加载时间 (秒) | 6.08 |
| 内存峰值 (GB) | 172.35 |
| 平均生成速度 (tokens/sec) | 44.21 |
| 平均首token延迟 (秒) | 0.07 |

## 测试详情

### 短文本生成

**Prompt:** 请用一句话解释量子计算...

- TTFT: 0.112 秒
- 生成速度: 27.61 tokens/sec
- 总tokens: 100
- 生成时间: 3.62 秒

**输出预览:**
```
用户用中文请求"请用一句话解释量子计算"，这是一个非常简洁的请求，要求用一句话解释量子计算这个复杂的概念。

让我思考如何用一句话准确而简洁地解释量子计算：

量子计算是一种利用量子力学原理（如叠加和纠缠）进行信息处理的新型计算方式，能够在特定问题上实现比传统计算机更高效的运算。

这个解释包含：
1. 核心技术基础：量子力学原理
2. 具体机制：叠加和纠缠
3. 对比优势：比
```

### 代码生成

**Prompt:** 写一个Python快速排序算法，包含完整注释...

- TTFT: 0.062 秒
- 生成速度: 48.93 tokens/sec
- 总tokens: 500
- 生成时间: 10.22 秒

**输出预览:**
```
我们使用递归实现快速排序。快速排序的基本思想是：
 1. 从数列中挑出一个元素，称为“基准”（pivot）。
 2. 重新排列数列，将比基准小的元素摆放在基准前面，比基准大的摆在基准后面（相同的数可以到任意一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作。
 3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。

 递归的终止条件是当子数组的大小为0或1时，自然有序。
</think>

以下是一个包含完整注释的Python快速排序算法实现：

```python
def quick_sort(arr):
    """
    快速排序算法实现
    
    算法原理：
    1. 选择一个基准元素（pivot）
    2. 将数组分成两部分：小于基准的元素放在左边，大于基准的元素放在右边
    3. 递归地对左右两部分进行排序
    
    参数说明：
    arr: 需要排序的列表
    
    返回值：
    已排序的列表
    """
    # 递归终止条件：当子数组长度小于等于1时，已经有序
    if le...
```

### 长文本生成

**Prompt:** 详细解释深度学习的反向传播算法，包括数学推导过程...

- TTFT: 0.063 秒
- 生成速度: 47.99 tokens/sec
- 总tokens: 2000
- 生成时间: 41.67 秒

**输出预览:**
```
用户想要详细解释深度学习的反向传播算法，包括数学推导过程。这是一个技术教育类内容，需要：

1. **写作类型**: 技术教程/教育文章，需要包含数学推导
2. **风格**: 学术/技术风格，严肃但易于理解
3. **受众**: 可能是机器学习初学者或需要回顾反向传播原理的人
4. **结构**: 
   - 引言（什么是反向传播，为什么重要）
   - 前向传播回顾
   - 链式法则（数学基础）
   - 简单网络的反向传播推导
   - 通用公式
   - 代码实现示例
   - 常见问题和注意事项

需要包含完整的数学推导，使用LaTeX公式。我会用中文回答，因为用户用中文提问。

让我开始撰写这个详细的技术解释。
</think>

# 深度学习反向传播算法详解

## 引言

反向传播（Backpropagation）是深度学习中训练神经网络的核心算法，它使得复杂的多层网络能够通过梯度下降法有效学习参数。可以说，没有反向传播算法，就没有现代深度学习的繁荣发展。反向传播的本质是一个利用链式法则高效计算梯度的过程，它从输出层开始，逐层向前计算每个参数对最终损失函数的影响程度。...
```

### 推理能力

**Prompt:** 有5个人排队，已知：A不在第一位，B在C前面，D紧挨着E，A在D后面。请推理出他们的排列顺序。...

- TTFT: 0.062 秒
- 生成速度: 48.32 tokens/sec
- 总tokens: 500
- 生成时间: 10.35 秒

**输出预览:**
```
We have a Chinese puzzle: "有5个人排队，已知：A不在第一位，B在C前面，D紧挨着E，A在D后面。请推理出他们的排列顺序。"

We need to determine the ordering of 5 people (A, B, C, D, E) based on constraints: A is not first; B is before C; D is next to E (adjacent); A is after D. So we need to find a linear ordering of 5 distinct persons satisfying these constraints. We need to output the ordering.

We must consider all constraints:

- Positions: positions 1 through 5.

- Constraint1: A != position 1.

- Constraint2: B before C (i.e., B appea...
```

### 指令跟随

**Prompt:** 请完成以下任务：
1. 列出3种常见的排序算法
2. 为每种算法写出时间复杂度
3. 用一句话总结它们的适用场景...

- TTFT: 0.063 秒
- 生成速度: 48.19 tokens/sec
- 总tokens: 400
- 生成时间: 8.30 秒

**输出预览:**
```
The user is speaking Chinese, asking to:

1. List 3 common sorting algorithms.
2. For each algorithm, write its time complexity.
3. Summarize their applicable scenarios in one sentence.

We must respond in Chinese. This is a straightforward request. No disallowed content. So we can comply.

We need to list 3 common sorting algorithms: e.g., Quick Sort, Merge Sort, Heap Sort, Insertion Sort, Bubble Sort, etc. Provide time complexities: best, average, worst. Then one sentence summarizing applicabl...
```
